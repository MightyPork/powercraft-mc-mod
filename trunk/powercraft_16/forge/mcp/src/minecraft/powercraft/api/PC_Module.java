package powercraft.api;


import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.minecraft.block.Block;
import net.minecraft.item.Item;
import net.minecraftforge.common.Configuration;
import powercraft.api.blocks.PC_Block;
import powercraft.api.blocks.PC_BlockInfo;
import powercraft.api.items.PC_Item;
import powercraft.api.items.PC_ItemInfo;
import powercraft.api.registries.PC_BlockRegistry;
import powercraft.api.registries.PC_ItemRegistry;
import powercraft.api.registries.PC_RecipeRegistry;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.Mod.EventHandler;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.ModMetadata;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;

/**
 * 
 * the base module class, all PowerCraft modules should extend this class
 * 
 * @author XOR
 *
 */
public abstract class PC_Module {
	
	public static final String POWERCRAFT = "PowerCraft";
	public static final String POWERCRAFT_URL = "http://powercrafting.net";
	public static final String POWERCRAFT_LOGOFILE = "/powercraft/PowerCraft.png";
	public static final String[] POWERCRAFT_AUTHORS = {"XOR", "Rapus", "Buggi"};
	public static final String POWERCRAFT_CREDITS = "MightyPork, RxD, LOLerul2";
	
	private Configuration config;
	private List<PC_Block> blocks = new ArrayList<PC_Block>();
	private List<PC_Item> items = new ArrayList<PC_Item>();

	/**
	 * forge preinit, when overridden, add @{@link EventHandler}
	 * @param event the forge event
	 */
	public abstract void preInit(FMLPreInitializationEvent event);

	/**
	 * forge init, when overridden, add @{@link EventHandler}
	 * @param event the forge event
	 */
	public abstract void init(FMLInitializationEvent event);

	/**
	 * forge postInit, when overridden, add @{@link EventHandler}
	 * @param event the forge event
	 */
	public abstract void postInit(FMLPostInitializationEvent event);

	/**
	 * default preinit, should be called from preInit()
	 * @param event the forge event
	 */
	protected void defaultPreInit(FMLPreInitializationEvent event) {

		ModMetadata metadata = getMetadata();
		PC_Logger.info("Create module %s", metadata.name);
		config = new Configuration(event.getSuggestedConfigurationFile());
		generateFields();
		saveConfig();
		metadata.autogenerated = false;
		metadata.url = POWERCRAFT_URL;
		metadata.logoFile = POWERCRAFT_LOGOFILE;
		metadata.description = getDescription();
		metadata.authorList = Arrays.asList(POWERCRAFT_AUTHORS);
		metadata.credits = POWERCRAFT_CREDITS;
		if (metadata.modId != PC_Api.instance.getMetadata().modId) PC_Api.instance.getMetadata().childMods.add(getContainer());
	}

	/**
	 * get the description of this module
	 * @return the description
	 */
	protected String getDescription(){
		return "";
	}
	
	/**
	 * default init, should be called from init()<br>
	 * here all field with @{@link PC_FieldGenerator} will be created
	 * @param event the forge event
	 */
	protected void defaultInit(FMLInitializationEvent event) {

		for (PC_Block block : blocks) {
			PC_RecipeRegistry.registerRecipes(this, block);
		}
		for (PC_Item item : items) {
			PC_RecipeRegistry.registerRecipes(this, item);
		}
	}

	/**
	 * generates the fields marked with @{@link PC_FieldGenerator}
	 */
	private void generateFields() {

		Field[] fields = getClass().getDeclaredFields();
		for (int i = 0; i < fields.length; i++) {
			if (fields[i].isAnnotationPresent(PC_FieldGenerator.class)) {
				generateField(fields[i]);
			}
		}
	}

	/**
	 * generates a field marked with @{@link PC_FieldGenerator}
	 * @param field the field to generate
	 */
	private void generateField(Field field) {

		PC_FieldGenerator generator = field.getAnnotation(PC_FieldGenerator.class);
		Class<?> clazz = generator.value();
		if (clazz == void.class) {
			clazz = field.getType();
		}
		try {
			Object object = createClass(clazz);
			field.setAccessible(true);
			field.set(this, object);
		} catch (Exception e) {
			e.printStackTrace();
			PC_Logger.severe("Failed to initialize field %s in module %s", field.getName(), getMetadata().name);
		}
	}

	/**
	 * generates a instance of a class
	 * @param clazz the class form which a instance should be created
	 */
	@SuppressWarnings("unchecked")
	private Object createClass(Class<?> clazz) throws InstantiationException, IllegalAccessException {

		if (Block.class.isAssignableFrom(clazz) && clazz.isAnnotationPresent(PC_BlockInfo.class)) {
			Block block = PC_BlockRegistry.registerBlock(this, (Class<? extends Block>) clazz);
			if (block instanceof PC_Block) {
				blocks.add((PC_Block) block);
			}
			return block;
		} else if (Item.class.isAssignableFrom(clazz) && clazz.isAnnotationPresent(PC_ItemInfo.class)) {
			Item item = PC_ItemRegistry.registerItem(this, (Class<? extends Item>) clazz);
			if (item instanceof PC_Item) {
				items.add((PC_Item) item);
			}
			return item;
		} else {
			return clazz.newInstance();
		}
	}

	/**
	 * get the {@link ModContainer} for this module
	 * @return the modContainer or null if none
	 */
	public ModContainer getContainer() {

		List<ModContainer> modContainers = Loader.instance().getModList();
		for (ModContainer modContainer : modContainers) {
			if (modContainer.matches(this)) {
				return modContainer;
			}
		}
		return null;
	}

	/**
	 * get the mod metadata
	 * @return the metadata
	 */
	public ModMetadata getMetadata() {

		ModContainer modContainer = getContainer();
		if(modContainer==null)
			return null;
		return modContainer.getMetadata();
	}

	/**
	 * returns the config of this module
	 * @return the config
	 */
	public Configuration getConfig() {

		return config;
	}

	/**
	 * saves the changed config
	 */
	public void saveConfig() {

		config.save();
	}

}
